<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>시간 기록표</title>
  <style>
    /* 기존 CSS 스타일 유지 */
    @font-face {
      font-family: 'FreeFont';
      src: url('https://park-1101.github.io/test/RepetitionScrolling.ttf') format('truetype');
    }
    body {
      background-color: black;
      color: white;
      margin: 0;
      padding: 0;
      font-family: 'FreeFont', sans-serif;
    }
    button {
      color: white;
      background-color: #333;
      border: 1px solid white;
      padding: 5px 10px;
      cursor: pointer;
      font-family: 'FreeFont', sans-serif;
    }
    #exportButton {
      position: absolute;
      top: 10px;
      right: 10px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      background-color: black;
      color: white;
      font-family: 'FreeFont', sans-serif;
    }
    th, td {
      border: 1px solid white;
      padding: 8px;
      text-align: center;
    }
    th {
      background-color: #333;
    }
    tr:hover {
      background-color: #444;
    }
    input {
      width: 100%;
      box-sizing: border-box;
      font-family: 'FreeFont', sans-serif;
    }
    #popup {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: white;
      padding: 20px;
      border: 1px solid #ccc;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      font-family: 'FreeFont', sans-serif;
    }
    #popup input {
      width: 200px;
      margin: 5px;
    }
    #popup button {
      margin-top: 10px;
    }
    #timeDisplay {
      margin-left: 10px;
      font-size: 16px;
      color: white;
    }
    #timeDifferenceDisplay {
      margin-left: 10px;
      font-size: 16px;
      color: white;
    }
    /* 소리크기 열(테이블의 4번째 열)의 고정 너비 지정 */
    #timeTable th:nth-child(4),
    #timeTable td:nth-child(4) {
      width: 60px;
    }
  </style>
</head>
<body>

  <!-- 기록 내보내기 버튼 -->
  <button id="exportButton" onclick="exportToHTML()">기록 내보내기</button>

  <h2>시간 기록표</h2>
  <p>아무 키나 누르면 시간이 기록됩니다.</p>
  <div style="display: flex; align-items: center;">
    <button onclick="openPopup()">시간 입력</button>
    <span id="timeDisplay"></span>
    <span id="timeDifferenceDisplay"></span>
  </div>

  <!-- 기록 시작/중지 토글 버튼 -->
  <button id="toggleRecordButton" onclick="toggleRecording()">기록 시작</button>

  <!-- 소리 레벨 임계값 설정 -->
  <div style="margin-top: 10px;">
    <label for="thresholdInput">소리 레벨 임계값 (0-255): </label>
    <input type="number" id="thresholdInput" min="0" max="255" value="100">
    <button onclick="setThreshold()">설정</button>
  </div>

  <table id="timeTable">
    <thead>
      <tr>
        <th>순번</th>
        <th id="currentTimeHeader">시간</th>
        <th>시간 차이</th>
        <th id="soundLevelHeader">소리크기: 소리레벨</th>
        <th>메모</th>
      </tr>
    </thead>
    <tbody>
    </tbody>
  </table>

  <!-- 팝업창 -->
  <div id="popup">
    <h3>시간 입력</h3>
    <input id="timeInput" placeholder="YYYY-MM-DD HH:MM:SS.SSS">
    <br>
    <button onclick="applyTime()">적용</button>
    <button onclick="closePopup()">닫기</button>
  </div>

  <script>
    let rowCount = 0;
    let isRecording = false;
    let audioContext, analyser, dataArray;
    let threshold = 100; // 기본 소리 레벨 임계값

    // 마지막 기록 시각(밀리초 단위) 저장 (0.3초 연속 기록 방지용)
    let lastRecordTime = 0;

    // Web Audio API 초기화
    function initAudio() {
      audioContext = new AudioContext();
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 256;
      const bufferLength = analyser.frequencyBinCount;
      dataArray = new Uint8Array(bufferLength);

      // 마이크 또는 라인 입력에 접근
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => {
          const source = audioContext.createMediaStreamSource(stream);
          source.connect(analyser);
          detectSound();
        })
        .catch(err => {
          console.error('오디오 장치 접근 실패:', err);
          alert('오디오 장치에 접근할 수 없습니다.');
        });
    }

    // 소리 감지 및 기록
    function detectSound() {
      analyser.getByteFrequencyData(dataArray);

      // 100Hz 이하 주파수 대역만 추출 (예: 0-5 인덱스)
      const lowFrequencyData = dataArray.slice(0, 5); // 100Hz 이하 대역
      const lowFrequencyAverage = lowFrequencyData.reduce((a, b) => a + b, 0) / lowFrequencyData.length;

      // 실시간으로 소리 크기를 헤더에 업데이트
      document.getElementById('soundLevelHeader').textContent = `소리크기: ${Math.round(lowFrequencyAverage)}`;

      // 소리 레벨이 임계값을 초과하면 기록 (소리 크기와 관계없이 0.3초 미만 연속 기록 방지)
      if (lowFrequencyAverage > threshold && isRecording) {
        addNewRow(lowFrequencyAverage);
      }

      requestAnimationFrame(detectSound);
    }

    // 임계값 설정
    function setThreshold() {
      const thresholdInput = document.getElementById('thresholdInput').value;
      threshold = parseInt(thresholdInput, 10);
      if (isNaN(threshold)) {
        alert('올바른 숫자를 입력해주세요.');
        return;
      }
      alert(`임계값이 ${threshold}로 설정되었습니다.`);
    }

    // 날짜/시간 포맷팅 함수
    function formatDateTime(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      const hours = String(date.getHours()).padStart(2, '0');
      const minutes = String(date.getMinutes()).padStart(2, '0');
      const seconds = String(date.getSeconds()).padStart(2, '0');
      const milliseconds = String(date.getMilliseconds()).padStart(3, '0');
      return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}.${milliseconds}`;
    }

    // 현재 시간 업데이트 (50ms 간격)
    function updateCurrentTime() {
      const now = new Date();
      const timeString = formatDateTime(now);
      document.getElementById('currentTimeHeader').textContent = timeString;
      const userInputTime = document.getElementById('timeInput').value;
      if (userInputTime) {
        const timeDifference = calculateTimeDifference(timeString, userInputTime);
        document.querySelector('#timeTable th:nth-child(3)').textContent = timeDifference;
        document.getElementById('timeDifferenceDisplay').textContent = timeDifference;
      }
    }
    setInterval(updateCurrentTime, 50);

    // 시간 차 계산 함수
    function calculateTimeDifference(currentTime, userInputTime) {
      const currentDate = new Date(currentTime);
      const userInputDate = new Date(userInputTime);
      if (isNaN(userInputDate.getTime())) {
        return `유효하지 않은 시간 (${userInputTime})`;
      }
      const differenceInMilliseconds = (currentDate - userInputDate);
      const differenceInSeconds = differenceInMilliseconds / 1000;
      const days = Math.floor(Math.abs(differenceInSeconds) / (3600 * 24));
      const hours = Math.floor((Math.abs(differenceInSeconds) % (3600 * 24)) / 3600);
      const minutes = Math.floor((Math.abs(differenceInSeconds) % 3600) / 60);
      const seconds = Math.floor(Math.abs(differenceInSeconds) % 60);
      const milliseconds = Math.abs(differenceInMilliseconds) % 1000;
      const sign = differenceInMilliseconds >= 0 ? '+' : '-';
      return `${sign}${days}D ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(3, '0')}`;
    }

    // 테이블 업데이트 함수
    function updateTable() {
      const tbody = document.querySelector('#timeTable tbody');
      const rows = tbody.querySelectorAll('tr');
      const userInputTime = document.querySelector('#timeInput').value || '';
      rows.forEach(row => {
        const currentTime = row.querySelector('td:nth-child(2)').textContent;
        const timeDifference = calculateTimeDifference(currentTime, userInputTime);
        row.querySelector('td:nth-child(3)').textContent = timeDifference;
      });
    }

    // 새로운 행 추가 (소리 레벨 포함)
    function addNewRow(volume) {
      if (!isRecording) return;

      // 현재 시각(밀리초 단위)를 확인하여 0.3초 미만이면 기록하지 않음
      const nowTimestamp = Date.now();
      if (lastRecordTime && (nowTimestamp - lastRecordTime < 300)) {
        return; // 0.3초 미만 연속 기록 방지
      }
      lastRecordTime = nowTimestamp;
      
      const roundedVolume = Math.round(volume);
      const now = new Date();
      const timeString = formatDateTime(now);
      const tbody = document.querySelector('#timeTable tbody');
      const newRow = document.createElement('tr');

      rowCount++;
      const userInputTime = document.querySelector('#timeInput').value || '';
      const timeDifference = calculateTimeDifference(timeString, userInputTime);

      newRow.innerHTML = `
        <td>${rowCount}</td>
        <td>${timeString}</td>
        <td>${timeDifference}</td>
        <td>${roundedVolume}</td>
        <td><input type="text" placeholder="메모 입력"></td>
      `;

      tbody.insertBefore(newRow, tbody.firstChild);

      // 순번에 따라 행 정렬
      const rows = Array.from(tbody.querySelectorAll('tr'));
      rows.sort((a, b) => {
        const aNum = parseInt(a.querySelector('td').textContent);
        const bNum = parseInt(b.querySelector('td').textContent);
        return bNum - aNum;
      });
      rows.forEach(row => tbody.appendChild(row));

      updateTable();
    }

    // 키 입력 시 기록 (PageUp, PageDown, Space)
    document.addEventListener('keydown', function(event) {
      if (event.key === 'PageUp' || event.key === 'PageDown' || event.key === ' ') {
        event.preventDefault();
        addNewRow(0); // 키 입력 시 소리 레벨은 0으로 설정
      }
    });

    // 기록 시작/중지 토글 함수
    function toggleRecording() {
      // AudioContext가 suspended 상태면 resume() 호출 (대부분의 브라우저는 사용자 상호작용 후 활성화됨)
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
          console.log('AudioContext resumed');
        });
      }
      isRecording = !isRecording;
      const button = document.getElementById('toggleRecordButton');
      button.textContent = isRecording ? '기록 중지' : '기록 시작';
      button.style.backgroundColor = isRecording ? '#006400' : '#8B4513';
      button.blur();
    }

    // 페이지 로드 시 초기 설정
    window.onload = function() {
      const now = new Date();
      const timeString = formatDateTime(now);
      document.getElementById('timeInput').value = timeString;
      document.getElementById('timeDisplay').textContent = timeString;
      document.getElementById('toggleRecordButton').style.backgroundColor = '#8B4513';
      initAudio(); // Web Audio API 초기화
    };

    // 팝업 열기/닫기 함수
    function openPopup() {
      document.getElementById('popup').style.display = 'block';
    }
    function closePopup() {
      document.getElementById('popup').style.display = 'none';
    }

    // 날짜/시간 형식 검증
    function isValidDateTime(input) {
      const regex = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3}$/;
      if (!regex.test(input)) {
        return false;
      }
      const date = new Date(input);
      return !isNaN(date.getTime());
    }

    // 팝업에서 시간 적용
    function applyTime() {
      const timeInput = document.getElementById('timeInput').value;
      if (!isValidDateTime(timeInput)) {
        alert('올바른 시간 형식이 아닙니다. YYYY-MM-DD HH:MM:SS.SSS 형식으로 입력해 주세요.');
        return;
      }
      document.getElementById('timeDisplay').textContent = timeInput;
      updateTable();
      closePopup();
    }

    // 시간 입력 필드 자동 포맷팅
    document.getElementById('timeInput').addEventListener('input', function(e) {
      const input = e.target.value.replace(/\D/g, '');
      let formatted = '';
      if (input.length > 0) {
        formatted += input.slice(0, 4);
        if (input.length > 4) {
          formatted += '-' + input.slice(4, 6);
          if (input.length > 6) {
            formatted += '-' + input.slice(6, 8);
            if (input.length > 8) {
              formatted += ' ' + input.slice(8, 10);
              if (input.length > 10) {
                formatted += ':' + input.slice(10, 12);
                if (input.length > 12) {
                  formatted += ':' + input.slice(12, 14);
                  if (input.length > 14) {
                    formatted += '.' + input.slice(14, 17);
                  }
                }
              }
            }
          }
        }
      }
      e.target.value = formatted;
    });

    // Enter 키 입력 시 시간 적용
    document.getElementById('timeInput').addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        applyTime();
      }
    });

    // 기록표 내보내기 함수 (메모 input의 현재 value를 반영)
    function exportToHTML() {
      const table = document.getElementById('timeTable');
      // 테이블을 클론하여 변경사항을 반영
      const clonedTable = table.cloneNode(true);
      // 클론된 테이블의 모든 input 요소에 대해, 현재 value를 value 속성(attribute)으로 설정
      clonedTable.querySelectorAll('input').forEach(input => {
        input.setAttribute('value', input.value);
      });

      const htmlContent = `
        <!DOCTYPE html>
        <html lang="ko">
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>시간 기록표 내보내기</title>
          <style>
            table {
              width: 100%;
              border-collapse: collapse;
              background-color: black;
              color: white;
            }
            th, td {
              border: 1px solid white;
              padding: 8px;
              text-align: center;
            }
            th {
              background-color: #333;
            }
          </style>
        </head>
        <body>
          ${clonedTable.outerHTML}
        </body>
        </html>
      `;
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = '시간_기록표.html';
      a.click();
      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
